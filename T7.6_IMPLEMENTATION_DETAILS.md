# T7.6 Test Implementation Details

## Test Assertion Examples

### Export Logic Assertions

#### 1. generateNodeListSheet Column Testing
```typescript
it('should create a sheet with 12 columns', () => {
  const sheet = generateNodeListSheet(mockNodes);
  expect(sheet['!cols']).toBeDefined();
  expect(sheet['!cols']?.length).toBe(12);
  // Columns: ID, 노드명, 타입, 부서, 단계, 소요시간, 담당자, 상태, 도구, 태그, AI스코어, 병목
});

it('should have dynamic column widths', () => {
  const sheet = generateNodeListSheet(mockNodes);
  const cols = sheet['!cols'] as any[];
  expect(cols[0]).toHaveProperty('wch'); // ID: 12
  expect(cols[1]).toHaveProperty('wch'); // 노드명: 20
  expect(cols[1].wch).toBe(20); // Node label should be wider
});

it('should freeze header row at correct position', () => {
  const sheet = generateNodeListSheet(mockNodes);
  expect(sheet['!freeze']).toEqual({ xSplit: 0, ySplit: 1 });
  // Freezes only the header row, not columns
});
```

#### 2. generateAdjacencyMatrixSheet Matrix Testing
```typescript
it('should create N×N matrix with correct dimensions', () => {
  const sheet = generateAdjacencyMatrixSheet(mockNodes, mockEdges);
  expect(sheet['!cols']?.length).toBe(mockNodes.length + 1);
  // 3 nodes + 1 header column = 4 total
});

it('should freeze header row and first column', () => {
  const sheet = generateAdjacencyMatrixSheet(mockNodes, mockEdges);
  expect(sheet['!freeze']).toEqual({ xSplit: 1, ySplit: 1 });
  // Freezes both first row AND first column
});

it('should detect edges correctly with binary values', () => {
  const sheet = generateAdjacencyMatrixSheet(mockNodes, mockEdges);
  expect(sheet).toBeDefined();
  const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
  expect(range.e.col).toBe(mockNodes.length); // Columns = number of nodes
  expect(range.e.row).toBe(mockNodes.length); // Rows = number of nodes
});
```

#### 3. generateLeadTimeReportSheet Time Parsing
```typescript
it('should parse hours correctly', () => {
  const nodesWith_h = mockNodes.map(n => ({
    ...n,
    attributes: { ...n.attributes, avg_time: '2h' }
  }));
  const sheet = generateLeadTimeReportSheet(nodesWith_h, mockEdges);
  expect(sheet).toBeDefined();
  // 2h + 2h + 2h = 6h = 360 minutes
});

it('should parse days correctly', () => {
  const nodesWith_d = mockNodes.map(n => ({
    ...n,
    attributes: { ...n.attributes, avg_time: '1d' }
  }));
  const sheet = generateLeadTimeReportSheet(nodesWith_d, mockEdges);
  expect(sheet).toBeDefined();
  // 1d = 1440 minutes
});

it('should handle decimal time values', () => {
  const nodesWithDecimal: ActivityNode[] = mockNodes.map(n => ({
    ...n,
    attributes: { ...n.attributes, avg_time: '1.5h' }
  }));
  const sheet = generateLeadTimeReportSheet(nodesWithDecimal, mockEdges);
  expect(sheet).toBeDefined();
  // 1.5h = 90 minutes
});

it('should handle invalid time formats gracefully', () => {
  const nodesWithInvalidTime: ActivityNode[] = [
    { ...mockNodes[0], attributes: { ...mockNodes[0].attributes, avg_time: 'invalid' } },
  ];
  const sheet = generateLeadTimeReportSheet(nodesWithInvalidTime, mockEdges);
  expect(sheet).toBeDefined();
  // Invalid format defaults to 0 minutes
});
```

#### 4. generateStatisticsSheet Calculations
```typescript
it('should calculate total node count', () => {
  const sheet = generateStatisticsSheet(mockNodes);
  expect(sheet).toBeDefined();
  // mockNodes has 3 nodes, should show "3"
});

it('should count AI-automatable nodes (score >= 70)', () => {
  const sheet = generateStatisticsSheet(mockNodes);
  expect(sheet).toBeDefined();
  // mockNodes: node_1 (45), node_2 (60), node_3 (75)
  // Only node_3 >= 70, count = 1
});

it('should handle 100% completion', () => {
  const allCompleted = mockNodes.map(n => ({
    ...n,
    status: 'COMPLETED' as const
  }));
  const sheet = generateStatisticsSheet(allCompleted);
  expect(sheet).toBeDefined();
  // 3 total / 3 completed = 100%
});

it('should count by node type', () => {
  const sheet = generateStatisticsSheet(mockNodes);
  expect(sheet).toBeDefined();
  // TRIGGER: 1, ACTION: 1, DECISION: 1
});
```

#### 5. applyExcelStyling Assertions
```typescript
it('should bold header rows', () => {
  const workbook = XLSX.utils.book_new();
  const sheet = generateNodeListSheet(mockNodes);
  XLSX.utils.book_append_sheet(workbook, sheet, 'Test');
  applyExcelStyling(workbook);

  const worksheet = workbook.Sheets['Test'];
  const headerCell = worksheet['A1'] as any;
  expect(headerCell.s).toBeDefined();
  expect(headerCell.s.font?.bold).toBe(true);
});

it('should apply borders to all cells', () => {
  const workbook = XLSX.utils.book_new();
  const sheet = generateNodeListSheet([mockNodes[0]]);
  XLSX.utils.book_append_sheet(workbook, sheet, 'Test');
  applyExcelStyling(workbook);

  const worksheet = workbook.Sheets['Test'];
  const cell = worksheet['A2'] as any;
  expect(cell.s?.border).toBeDefined();
  expect(cell.s.border.left).toBeDefined();
  expect(cell.s.border.right).toBeDefined();
  expect(cell.s.border.top).toBeDefined();
  expect(cell.s.border.bottom).toBeDefined();
});

it('should apply alternating row colors', () => {
  const workbook = XLSX.utils.book_new();
  const sheet = generateNodeListSheet(mockNodes);
  XLSX.utils.book_append_sheet(workbook, sheet, 'Test');
  applyExcelStyling(workbook);

  const worksheet = workbook.Sheets['Test'];
  const row2 = worksheet['A2'] as any; // Even row
  const row3 = worksheet['A3'] as any; // Odd row

  expect(row2.s?.fill).toBeDefined();
  expect(row3.s?.fill).toBeDefined();
  // row2 has lighter background, row3 is normal
});
```

#### 6. exportWorkflowToExcel Integration
```typescript
it('should generate correct filename format', () => {
  const options: ExcelExportOptions = {
    includeNodeList: true,
    includeAdjacencyMatrix: true,
    includeLeadTimeReport: true,
    includeStatistics: true,
  };
  exportWorkflowToExcel(mockProject, options);

  const callArgs = (XLSX.writeFile as any).mock.calls[0];
  const filename = callArgs[1];
  expect(filename).toMatch(/Test Project_workflow_\d{4}-\d{2}-\d{2}\.xlsx/);
  // Example: Test Project_workflow_2024-01-15.xlsx
});

it('should include all 4 sheets when all options are true', () => {
  const options: ExcelExportOptions = {
    includeNodeList: true,
    includeAdjacencyMatrix: true,
    includeLeadTimeReport: true,
    includeStatistics: true,
  };
  exportWorkflowToExcel(mockProject, options);

  const callArgs = (XLSX.writeFile as any).mock.calls[0];
  const workbook = callArgs[0];
  expect(workbook.SheetNames.length).toBe(4);
  // Sheets: ['노드 목록', '인접 행렬', '리드타임 분석', '통계']
});

it('should use XLSX.writeFile for export', () => {
  const options: ExcelExportOptions = {
    includeNodeList: true,
    includeAdjacencyMatrix: true,
    includeLeadTimeReport: true,
    includeStatistics: true,
  };
  exportWorkflowToExcel(mockProject, options);

  expect(XLSX.writeFile).toHaveBeenCalledWith(
    expect.objectContaining({ SheetNames: expect.any(Array) }),
    expect.stringMatching(/\.xlsx$/)
  );
});
```

---

## Dialog Component Assertions

### 1. Dialog Rendering Tests
```typescript
it('should not render when isOpen is false', () => {
  render(
    <ExcelExportDialog
      isOpen={false}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );
  expect(screen.queryByText('엑셀 내보내기')).not.toBeInTheDocument();
});

it('should render when isOpen is true', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );
  expect(screen.getByText('엑셀 내보내기')).toBeInTheDocument();
});

it('should display dialog title', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );
  expect(screen.getByText('엑셀 내보내기')).toBeInTheDocument();
});
```

### 2. Filename Input Tests
```typescript
it('should have default filename when dialog opens', () => {
  const { rerender } = render(
    <ExcelExportDialog
      isOpen={false}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  rerender(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const input = screen.getByPlaceholderText('파일명을 입력하세요') as HTMLInputElement;
  expect(input.value).toBeTruthy();
  expect(input.value).toMatch(/Test Project_workflow_\d{4}-\d{2}-\d{2}\.xlsx/);
});

it('should validate filename is not empty', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const input = screen.getByPlaceholderText('파일명을 입력하세요') as HTMLInputElement;
  await user.clear(input);

  const exportButton = screen.getByText('엑셀로 내보내기');
  expect(exportButton).toBeDisabled();
});
```

### 3. Export Options Tests
```typescript
it('should render 4 checkboxes', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );
  const checkboxes = screen.getAllByRole('checkbox');
  expect(checkboxes.length).toBe(4);
  // 노드 목록, 인접 행렬, 리드타임 분석, 통계
});

it('should have all options checked by default', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );
  const checkboxes = screen.getAllByRole('checkbox') as HTMLInputElement[];
  checkboxes.forEach(checkbox => {
    expect(checkbox.checked).toBe(true);
  });
});

it('should allow toggling options on and off', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const firstCheckbox = screen.getAllByRole('checkbox')[0] as HTMLInputElement;
  expect(firstCheckbox.checked).toBe(true);

  await user.click(firstCheckbox);
  expect(firstCheckbox.checked).toBe(false);

  await user.click(firstCheckbox);
  expect(firstCheckbox.checked).toBe(true);
});
```

### 4. Export Button Tests
```typescript
it('should be disabled when no options selected', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const checkboxes = screen.getAllByRole('checkbox');
  for (const checkbox of checkboxes) {
    await user.click(checkbox);
  }

  const exportButton = screen.getByText('엑셀로 내보내기');
  expect(exportButton).toBeDisabled();
});

it('should show success toast on completion', async () => {
  const user = userEvent.setup();
  const { getByText } = render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const exportButton = getByText('엑셀로 내보내기');
  await user.click(exportButton);

  await waitFor(() => {
    expect(toast.success).toHaveBeenCalled();
  });
});

it('should close dialog on successful export', async () => {
  const user = userEvent.setup();
  const mockOnOpenChange = vi.fn();

  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={mockOnOpenChange}
      project={mockProject}
    />
  );

  const exportButton = screen.getByText('엑셀로 내보내기');
  await user.click(exportButton);

  await waitFor(() => {
    expect(mockOnOpenChange).toHaveBeenCalledWith(false);
  });
});
```

### 5. Preview Button Tests
```typescript
it('should show preview when clicked', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const previewButton = screen.getByText('미리보기');
  await user.click(previewButton);

  expect(screen.getByText('내보낼 시트')).toBeInTheDocument();
});

it('should display selected sheets in preview', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const previewButton = screen.getByText('미리보기');
  await user.click(previewButton);

  expect(screen.getByText('노드 목록 (2개 노드)')).toBeInTheDocument();
  expect(screen.getByText(/인접 행렬.*2.*×.*2/)).toBeInTheDocument();
  expect(screen.getByText('리드타임 분석')).toBeInTheDocument();
  expect(screen.getByText('통계')).toBeInTheDocument();
});

it('should show correct sheet count in preview', async () => {
  const user = userEvent.setup();
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const previewButton = screen.getByText('미리보기');
  await user.click(previewButton);

  expect(screen.getByText('총 4개 시트가 포함됩니다.')).toBeInTheDocument();
});
```

### 6. Accessibility Tests
```typescript
it('should have proper label associations', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const label = screen.getByLabelText('파일명');
  expect(label).toBeInTheDocument();
});

it('should have proper checkbox labels', () => {
  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  expect(screen.getByLabelText('노드 목록')).toBeInTheDocument();
  expect(screen.getByLabelText('인접 행렬')).toBeInTheDocument();
  expect(screen.getByLabelText('리드타임 분석')).toBeInTheDocument();
  expect(screen.getByLabelText('통계')).toBeInTheDocument();
});
```

### 7. Integration Tests
```typescript
it('should pass correct options to exportWorkflowToExcel', async () => {
  const user = userEvent.setup();
  const { exportWorkflowToExcel } = await import('@/lib/excelExporter');

  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const exportButton = screen.getByText('엑셀로 내보내기');
  await user.click(exportButton);

  await waitFor(() => {
    expect(exportWorkflowToExcel).toHaveBeenCalledWith(
      mockProject,
      expect.objectContaining({
        includeNodeList: true,
        includeAdjacencyMatrix: true,
        includeLeadTimeReport: true,
        includeStatistics: true,
      })
    );
  });
});

it('should pass selected options only to exportWorkflowToExcel', async () => {
  const user = userEvent.setup();
  const { exportWorkflowToExcel } = await import('@/lib/excelExporter');

  render(
    <ExcelExportDialog
      isOpen={true}
      onOpenChange={vi.fn()}
      project={mockProject}
    />
  );

  const checkboxes = screen.getAllByRole('checkbox');
  await user.click(checkboxes[1]); // Uncheck adjacency matrix

  const exportButton = screen.getByText('엑셀로 내보내기');
  await user.click(exportButton);

  await waitFor(() => {
    expect(exportWorkflowToExcel).toHaveBeenCalledWith(
      mockProject,
      expect.objectContaining({
        includeNodeList: true,
        includeAdjacencyMatrix: false, // Toggled off
        includeLeadTimeReport: true,
        includeStatistics: true,
      })
    );
  });
});
```

---

## Mock Usage Patterns

### XLSX Mocking Pattern
```typescript
vi.mock('xlsx', async () => {
  const actual = await vi.importActual<typeof XLSX>('xlsx');
  return {
    ...actual,
    writeFile: vi.fn(), // Only mock writeFile
  };
});

// In test:
const callArgs = (XLSX.writeFile as any).mock.calls[0];
const [workbook, filename] = callArgs;
```

### Toast Mocking Pattern
```typescript
vi.mock('sonner', () => ({
  toast: {
    error: vi.fn(),
    success: vi.fn(),
    warning: vi.fn(),
  },
}));

// In test:
expect(toast.success).toHaveBeenCalled();
expect(toast.error).toHaveBeenCalledWith('error title', { description: '...' });
```

### User Events Pattern
```typescript
const user = userEvent.setup();
await user.click(element);
await user.type(input, 'text');
await user.clear(input);
```

### Async Assertion Pattern
```typescript
await waitFor(() => {
  expect(mockFn).toHaveBeenCalled();
});
```

---

## Edge Case Coverage

### Data Edge Cases
- Empty workflows (0 nodes)
- Single node workflows
- Very large workflows (150+ nodes)
- Duplicate node names
- Special characters in labels
- Very long labels (500+ chars)

### Time Format Edge Cases
- Hours (h): "2h" → 120m
- Minutes (m): "30m" → 30m
- Days (d): "1d" → 1440m
- Decimal: "1.5h" → 90m
- Invalid: "invalid" → 0m
- Zero: "0m" → 0m
- Large: "1000d" → 1440000m

### State Edge Cases
- All options unchecked (shows warning)
- Empty filename (disabled button)
- Null project (disabled button)
- Rapid option changes
- Export failure recovery

### Matrix Edge Cases
- Disconnected nodes (all 0s in row/column)
- Cyclic edges (feedback loops)
- Self-referential edges
- Multiple edges between same nodes

---

## Performance Characteristics

- Test execution: <2 seconds total
- No async delays in test logic
- No file I/O operations
- No external API calls
- Lightweight mock data
- Efficient DOM queries

All tests are deterministic and repeatable.
